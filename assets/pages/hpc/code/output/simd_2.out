;  @ none:1 within `mysum`
define double @julia_mysum_5125({}* nonnull align 16 dereferenceable(40) %0) #0 {
top:
;  @ none:4 within `mysum`
; ┌ @ abstractarray.jl:279 within `eachindex`
; │┌ @ abstractarray.jl:116 within `axes1`
; ││┌ @ abstractarray.jl:95 within `axes`
; │││┌ @ array.jl:151 within `size`
      %1 = bitcast {}* %0 to {}**
      %2 = getelementptr inbounds {}*, {}** %1, i64 3
      %3 = bitcast {}** %2 to i64*
      %4 = load i64, i64* %3, align 8
; └└└└
; ┌ @ range.jl:833 within `iterate`
; │┌ @ range.jl:609 within `isempty`
; ││┌ @ operators.jl:378 within `>`
; │││┌ @ int.jl:83 within `<`
      %.not.not = icmp eq i64 %4, 0
; └└└└
  br i1 %.not.not, label %L31, label %L14.preheader

L14.preheader:                                    ; preds = %top
  %5 = bitcast {}* %0 to double**
  %6 = load double*, double** %5, align 8
;  @ none:5 within `mysum`
  br label %L14

L14:                                              ; preds = %L14, %L14.preheader
  %value_phi3 = phi i64 [ %11, %L14 ], [ 1, %L14.preheader ]
  %value_phi5 = phi double [ %10, %L14 ], [ 0.000000e+00, %L14.preheader ]
; ┌ @ array.jl:861 within `getindex`
   %7 = add nsw i64 %value_phi3, -1
   %8 = getelementptr inbounds double, double* %6, i64 %7
   %9 = load double, double* %8, align 8
; └
; ┌ @ float.jl:399 within `+`
   %10 = fadd double %value_phi5, %9
; └
; ┌ @ range.jl:837 within `iterate`
; │┌ @ promotion.jl:468 within `==`
    %.not = icmp eq i64 %value_phi3, %4
; │└
   %11 = add nuw nsw i64 %value_phi3, 1
; └
  br i1 %.not, label %L31, label %L14

L31:                                              ; preds = %L14, %top
  %value_phi9 = phi double [ 0.000000e+00, %top ], [ %10, %L14 ]
;  @ none:8 within `mysum`
  ret double %value_phi9
}

------Separator-------

;  @ none:1 within `mysimdsum`
define double @julia_mysimdsum_5140({}* nonnull align 16 dereferenceable(40) %0) #0 {
top:
;  @ none:4 within `mysimdsum`
; ┌ @ simdloop.jl:69 within `macro expansion`
; │┌ @ abstractarray.jl:279 within `eachindex`
; ││┌ @ abstractarray.jl:116 within `axes1`
; │││┌ @ abstractarray.jl:95 within `axes`
; ││││┌ @ array.jl:151 within `size`
       %1 = bitcast {}* %0 to {}**
       %2 = getelementptr inbounds {}*, {}** %1, i64 3
       %3 = bitcast {}** %2 to i64*
       %4 = load i64, i64* %3, align 8
; └└└└└
; ┌ @ simdloop.jl:72 within `macro expansion`
; │┌ @ int.jl:83 within `<`
    %.not = icmp eq i64 %4, 0
; │└
   br i1 %.not, label %L30, label %L13.lr.ph

L13.lr.ph:                                        ; preds = %top
   %5 = bitcast {}* %0 to double**
   %6 = load double*, double** %5, align 8
; └
; ┌ @ simdloop.jl:75 within `macro expansion`
   %min.iters.check = icmp ult i64 %4, 16
   br i1 %min.iters.check, label %L13, label %vector.ph

vector.ph:                                        ; preds = %L13.lr.ph
   %n.vec = and i64 %4, 9223372036854775792
   br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
; └
; ┌ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
    %vec.phi = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %15, %vector.body ]
    %vec.phi9 = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %16, %vector.body ]
    %vec.phi10 = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %17, %vector.body ]
    %vec.phi11 = phi <4 x double> [ zeroinitializer, %vector.ph ], [ %18, %vector.body ]
; └└
; ┌ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ array.jl:861 within `getindex`
    %7 = getelementptr inbounds double, double* %6, i64 %index
    %8 = bitcast double* %7 to <4 x double>*
    %wide.load = load <4 x double>, <4 x double>* %8, align 8
    %9 = getelementptr inbounds double, double* %7, i64 4
    %10 = bitcast double* %9 to <4 x double>*
    %wide.load12 = load <4 x double>, <4 x double>* %10, align 8
    %11 = getelementptr inbounds double, double* %7, i64 8
    %12 = bitcast double* %11 to <4 x double>*
    %wide.load13 = load <4 x double>, <4 x double>* %12, align 8
    %13 = getelementptr inbounds double, double* %7, i64 12
    %14 = bitcast double* %13 to <4 x double>*
    %wide.load14 = load <4 x double>, <4 x double>* %14, align 8
; │└
; │┌ @ float.jl:399 within `+`
    %15 = fadd fast <4 x double> %vec.phi, %wide.load
    %16 = fadd fast <4 x double> %vec.phi9, %wide.load12
    %17 = fadd fast <4 x double> %vec.phi10, %wide.load13
    %18 = fadd fast <4 x double> %vec.phi11, %wide.load14
; └└
; ┌ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %index.next = add i64 %index, 16
    %19 = icmp eq i64 %index.next, %n.vec
    br i1 %19, label %middle.block, label %vector.body

middle.block:                                     ; preds = %vector.body
; └└
; ┌ @ simdloop.jl:75 within `macro expansion`
   %bin.rdx = fadd fast <4 x double> %16, %15
   %bin.rdx15 = fadd fast <4 x double> %17, %bin.rdx
   %bin.rdx16 = fadd fast <4 x double> %18, %bin.rdx15
   %20 = call fast double @llvm.vector.reduce.fadd.v4f64(double -0.000000e+00, <4 x double> %bin.rdx16)
   %cmp.n = icmp eq i64 %4, %n.vec
   br i1 %cmp.n, label %L30, label %L13

L13:                                              ; preds = %L13, %middle.block, %L13.lr.ph
   %value_phi18 = phi i64 [ %24, %L13 ], [ %n.vec, %middle.block ], [ 0, %L13.lr.ph ]
   %value_phi7 = phi double [ %23, %L13 ], [ %20, %middle.block ], [ 0.000000e+00, %L13.lr.ph ]
; └
; ┌ @ simdloop.jl:77 within `macro expansion` @ none:5
; │┌ @ array.jl:861 within `getindex`
    %21 = getelementptr inbounds double, double* %6, i64 %value_phi18
    %22 = load double, double* %21, align 8
; │└
; │┌ @ float.jl:399 within `+`
    %23 = fadd fast double %value_phi7, %22
; └└
; ┌ @ simdloop.jl:78 within `macro expansion`
; │┌ @ int.jl:87 within `+`
    %24 = add nuw nsw i64 %value_phi18, 1
; └└
; ┌ @ simdloop.jl:75 within `macro expansion`
; │┌ @ int.jl:83 within `<`
    %exitcond.not = icmp eq i64 %24, %4
; │└
   br i1 %exitcond.not, label %L30, label %L13

L30:                                              ; preds = %L13, %middle.block, %top
   %value_phi2 = phi double [ 0.000000e+00, %top ], [ %20, %middle.block ], [ %23, %L13 ]
; └
;  @ none:8 within `mysimdsum`
  ret double %value_phi2
}
