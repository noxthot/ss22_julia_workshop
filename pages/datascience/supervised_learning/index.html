<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/ss22_julia_workshop/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/ss22_julia_workshop/libs/highlight/github.min.css">
   
    <script src="/ss22_julia_workshop/libs/clipboard.min.js"></script>
  
  
  <script src="/ss22_julia_workshop/libs/plotly-1_58_5.min.js"></script> 
  <script>
    // This function is used when calling `\fig{...}` See # Using \fig{...} below
    const PlotlyJS_json = async (div, url) => {
      response = await fetch(url); // get file
      fig = await response.json(); // convert it to json
      // Make the plot fit the screen responsively. See the documentation of plotly.js. https://plotly.com/javascript/responsive-fluid-layout/
      if (typeof fig.config === 'undefined') { fig["config"]={} }
      delete fig.layout.width
      delete fig.layout.height
      fig["layout"]["autosize"] = true
      fig["config"]["autosizable"] = true
      fig["config"]["responsive"] = true

      // make it easier to scroll throught the website rather than being blocked by a figure.
      fig.config["scrollZoom"] = false

      // PlotlyJS.savefig by default add the some more attribute to make a static plot.
      // Disable them to make the website fancier.
      delete fig.config.staticPlot
      delete fig.config.displayModeBar
      delete fig.config.doubleClick
      delete fig.config.showTips

      Plotly.newPlot(div, fig);
    };
  </script>
  
  <link rel="stylesheet" href="/ss22_julia_workshop/css/jtd.css">
<link rel="stylesheet" href="/ss22_julia_workshop/css/extras.css">
<link rel="icon" href="/ss22_julia_workshop/assets/favicon.ico">

<style>
  /* #148 wrap long header */
  .franklin-content a.header-anchor,
  .franklin-toc li a
   {
    word-wrap: break-word;
    white-space: normal;
  }
</style>

   <title>Supervised Learning</title>  
</head>
<body>                      <!-- closed in foot.html -->
<div class="page-wrap">   <!-- closed in foot.html -->
  <!-- SIDE BAR -->
  <div class="side-bar">
    <div class="header">
      <a href="/ss22_julia_workshop/" class="title">
        Julia
      </a>
    </div>
    <label for="show-menu" class="show-menu">MENU</label>
    <input type="checkbox" id="show-menu" role="button">
    <div class="menu" id="side-menu">
      <ul class="menu-list">
        <li class="menu-list-item "><a href="/ss22_julia_workshop/" class="menu-list-link ">Start</a>
        <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/" class="menu-list-link ">Introduction</a>
          <ul class="menu-list-child-list ">
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/basis_datatypes_and_operations" class="menu-list-link ">Basic Data Types and Operations</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/package_manager" class="menu-list-link ">Package Manager</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/matrix_vectors" class="menu-list-link ">Matrix and Vector Operations</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/conditional_evaluations" class="menu-list-link ">Conditional evaluations</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/loops" class="menu-list-link ">Loops</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/functions" class="menu-list-link ">Functions</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/macros" class="menu-list-link ">Macros</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/worksheet_1" class="menu-list-link ">Worksheet 1</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/worksheet_2" class="menu-list-link ">Worksheet 2</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/pluto" class="menu-list-link ">Pluto Notebook</a>
          </ul>
        <li class="menu-list-item active"><a href="/ss22_julia_workshop/pages/datascience/" class="menu-list-link active">Data Science</a>
          <ul class="menu-list-child-list ">
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/loading_data" class="menu-list-link ">Loading data</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/saving_data" class="menu-list-link ">Saving data</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/exploratory_da" class="menu-list-link ">Exploratory Data Analysis</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/datasets" class="menu-list-link ">Data Sets</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/unsupervised_learning" class="menu-list-link ">Unsupervised Learning</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/supervised_learning" class="menu-list-link active">Supervised Learning</a>
          </ul>
        <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/" class="menu-list-link ">Parallel computing</a>
          <ul class="menu-list-child-list ">
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/performance" class="menu-list-link ">Measuring performance</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/simd" class="menu-list-link ">Single Instruction Multiple Data</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/pi" class="menu-list-link ">&pi; example</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/multithreading" class="menu-list-link ">Multithreading</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/distributed" class="menu-list-link ">Distributed computing</a>
            <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/gpu" class="menu-list-link ">GPU computing</a>
          </ul>
      </ul>
    </div>
    <div class="footer">
      This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target="_blank">Jekyll theme</a>.
    </div>
  </div>
  <!-- CONTENT -->
  <div class="main-content-wrap"> <!-- closed in foot.html -->
    <div class="main-content">    <!-- closed in foot.html -->
      <div class="main-header">
        SS22 Julia Workshop Obergurgl
      </div>



<!-- Content appended here (in class franklin-content) -->
<div class="franklin-content"><h1 id="supervised_learning"><a href="#supervised_learning" class="header-anchor">Supervised learning</a></h1>
<div class="franklin-toc"><ol><li><a href="#classification_k_nearest_neighbours">Classification &#40;K Nearest Neighbours&#41;</a><ol><li><a href="#theory">Theory</a></li><li><a href="#application">Application</a></li></ol></li><li><a href="#pluto_notebook">Pluto Notebook</a></li></ol></div>
<p>The goal of <em>supervised learning</em> is to learn a function that maps inputs to outputs based on input data that has been labeled for a particular output. Usually the algorithms fall into two categories:</p>
<ul>
<li><p><strong>Classification tasks</strong>: Here, supervised learning tries to predict the category a data point belongs to. This is e.g. used in spam detection, speech recognition, describing images or handwriting recognition.</p>
</li>
<li><p><strong>Regression tasks</strong>: Here, supervised learning is used to predict a continuous numerical value based on an input data point. This is e.g. used in sales forecasting or temperature forecasting.</p>
</li>
</ul>
<p>In this section we will just look into one classification task and we will do so by applying <em>K nearest neighbours</em> &#40;KNN&#41;.</p>
<p>We continue to work with the MNIST data set and since we are experimenting with supervised learning, we need to use the training as well as the test data set including the labels.</p>
<p>In case you do not have <code>X_train</code>, <code>X_test</code>, <code>y_train</code> and <code>y_test</code> at hand, take a look at the following code:</p>
<button type="button" class="collapsible" style="background-color:#fffca5"> Solution </button><div class="collapsiblecontent">  </p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> MLDatasets

df_train = MNIST(:train)
df_test = MNIST(:test)

X_train = reshape(df_train.features, (<span class="hljs-number">28</span> * <span class="hljs-number">28</span>, :))&#x27;
y_train = df_train.targets
X_test = reshape(df_test.features, (<span class="hljs-number">28</span> * <span class="hljs-number">28</span>, :))&#x27;
y_test = df_test.targets</code></pre>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext></mrow><annotation encoding="application/x-tex">~</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;"></span><span class="mspace nobreak"> </span></span></span></span> </div>
<h2 id="classification_k_nearest_neighbours"><a href="#classification_k_nearest_neighbours" class="header-anchor">Classification &#40;K Nearest Neighbours&#41;</a></h2>
<h3 id="theory"><a href="#theory" class="header-anchor">Theory</a></h3>
<p>The K nearest neighbours is one of the simplest algorithms used for classification tasks. Recall that our data is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>784</mn></mrow><annotation encoding="application/x-tex">784</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">784</span></span></span></span>-dimensional and every data point corresponds to one handwritten digit. If we want to make a prediction for a previously unseen handwritten digit, we simply flatten the matrix, put the point in our <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>784</mn></mrow><annotation encoding="application/x-tex">784</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">784</span></span></span></span>-dimensional space and find the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> nearest neighbours &#40;depending on a predefined metric&#41; within the training data set. We then look at the labels of these nearest neighbours and get a majority vote. So if most of the neighbours are of category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>, then the prediction of the previously unseen handwritten digit would also be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>. This image illustrates this process: 
<figure style="text-align:center;">
<img src="/ss22_julia_workshop/assets/pages/datascience/supervised_knn.png" style="padding:0; " alt=" MNIST data set."/>
<figcaption> MNIST data set. Original source: <p style="font-size:11px"><a href=" https://commons.wikimedia.org/wiki/File:K_nearest_neighbour_explain.png"> https://commons.wikimedia.org/wiki/File:K_nearest_neighbour_explain.png</a></p></figcaption>
</figure>
</p>
<h3 id="application"><a href="#application" class="header-anchor">Application</a></h3>
<p>Again we will use <code>MLJ</code> to apply the KNN algorithm. The workflow stays exactly the same and we even have multiple implementations to choose from. In this workshop we will use the <code>KNNClassifier</code> from the <a href="https://github.com/JuliaAI/NearestNeighborModels.jl"><code>NearestNeighborModels.jl</code></a> package. Since we are already used to work with <code>MLJ</code>, we will leave this as an exercise.</p>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Use KNN to predict the labels of the test set:</p>
<ol>
<li><p>Load the model</p>
</li>
<li><p>Instantiate the model with option <code>K&#61;10</code>.</p>
</li>
<li><p>Check whether sci types are correct for input and label &#40;target&#41;.</p>
</li>
<li><p>Transform inputs and labels of training and test set such that sci types are compatible. Hint: Look at the manual of <code>categorical&#40;&#41;</code>.</p>
</li>
<li><p>Initialize the machine.</p>
</li>
<li><p>Fit the model&#39;s parameters.</p>
</li>
<li><p>Use <code>MLJ.predict</code> to get the predictions for the test set. Warning: This will probably take a couple of minutes.</p>
</li>
<li><p>To convert the results of <code>predict</code> into real labels, use <code>pred_vector &#61; Vector&#123;Int64&#125;&#40;mode.&#40;pred_test&#41;&#41;</code>.</p>
</li>
</ol>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  </p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> DataFrames, MLJ, NearestNeighborModels

KNN = <span class="hljs-meta">@load</span> KNNClassifier pkg=NearestNeighborModels
model_knn = KNN(K=<span class="hljs-number">10</span>)

X_train_tab = MLJ.table(X_train)
X_test_tab = MLJ.table(X_test)

y_train_cat = categorical(y_train)
y_test_cat = categorical(y_test)

mach_knn = machine(model_knn, X_train_tab, y_train_cat)
fit!(mach_knn)

pred_test = MLJ.predict(mach_knn, X_test_tab)
pred_vector = <span class="hljs-built_in">Vector</span>{<span class="hljs-built_in">Int64</span>}(mode.(pred_test))</code></pre>
<p></div> </div>
<p>Note that running <code>predict</code> is quite slow in this case. For every data point in the test set we need to find the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span> nearest neighbours within the training data set. Thus we need to compute <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10000</mn><mo>∗</mo><mn>60000</mn></mrow><annotation encoding="application/x-tex">10000 * 60000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">60000</span></span></span></span> metrics which takes a while. After finishing the exercise, we should have a vector with predicted labels of previously unseen data &#40;test set&#41;. Now we are interested in the quality of these predictions, so we compare them to real labels. One method to do so is the <a href="https://en.wikipedia.org/wiki/Confusion_matrix">confusion matrix</a>. Each column represents instances of the real &#40;expected&#41; value while each row represents the predicted value. The diagonal shows the correct predictions and every other matrix element the missclassifications. We will use the confusion matrix implementation that is available in the <code>KnetMetrics.jl</code> package since it supports confusion matrices with more than two classes.</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> <span class="hljs-keyword">using</span> KnetMetrics
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> conf_mat = KnetMetrics.confusion_matrix(pred_vector, y_test)
</span>conf_mat =

                                  Expected

      0      1      2      3      4      5      6      7      8      9
______________________________________________________________________
    972      0     13      0      2      4      6      0      6      7   │0 
      1   1132     12      3     11      0      4     27      4      6   │1 
      1      2    982      3      0      0      0      4      5      3   │2 
      0      0      2    976      0     12      0      0     11      7   │3 
      0      0      1      1    940      1      3      2      7     10   │4 
      2      0      0     10      0    863      2      0      9      3   │5	Predicted
      3      1      2      1      4      6    943      0      4      1   │6 
      1      0     17      7      1      1      0    983      7     10   │7 
      0      0      3      6      1      1      0      0    914      2   │8 
      0      0      0      3     23      4      0     12      7    960   │9</code></pre>
<p>The confusion matrix tells us that our model is almost perfectly recognizing <code>0</code>, <code>1</code>, <code>6</code>, but is doing worse with classifying <code>2</code>, <code>4</code> or <code>7</code> correctly. To get the accuracy, we can use <code>MLJ.accuracy</code>:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> MLJ.accuracy(pred_vector, y_test)
</span>0.9665</code></pre>
<p>So our KNN reached an accuracy of 96.7&#37; which is really amazing already. In case you are interested how other algorithms perform, have a look at the <a href="https://en.wikipedia.org/wiki/MNIST_database#Classifiers">MNIST database article</a> on Wikipedia.</p>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  How is changing <code>K</code> affecting the prediction accuracy? </div>
<h2 id="pluto_notebook"><a href="#pluto_notebook" class="header-anchor">Pluto Notebook</a></h2>
<button type="button" class="collapsible" style="background-color:#fffca5"> Solution </button><div class="collapsiblecontent">  <a href="/ss22_julia_workshop/notebooks/html/ds_supervised.jl">Click here</a> to download the complementary Pluto notebook. </div>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> - <a href="https://ehrensperger.dev/">Gregor Ehrensperger</a>, <a href="https://lfuonline.uibk.ac.at/public/people.vcard?id=59131">Peter Kandolf</a>, <a href="https://lfuonline.uibk.ac.at/public/people.vcard?id=415344">Jonas Kusch</a>. Last modified: July 21, 2022.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    </div> <!-- end of class main-content -->
    </div> <!-- end of class main-content-wrap -->
    </div> <!-- end of class page-wrap-->
    
      



    
    
      


      <script>
    (function(){
    
      // Get the elements.
      // - the 'pre' element.
      // - the 'div' with the 'paste-content' id.
    
      var pre = document.getElementsByTagName('pre');
    
      // Add a copy button in the 'pre' element.
      // which only has the className of 'language-'.
    
      for (var i = 0; i < pre.length; i++) {
        var isLanguage = pre[i].children[0].tagName == 'CODE';
    
        if ( isLanguage ) {
          var button           = document.createElement('button');
              button.className = 'copy-button';
              button.textContent = 'Copy';
    
              pre[i].appendChild(button);
        }
      };
    
      // Run Clipboard
    
      var copyCode = new Clipboard('.copy-button', {
        target: function(trigger) {
          return trigger.previousElementSibling;
        }
      });
    
      // On success:
      // - Change the "Copy" text to "Copied".
      // - Swap it to "Copy" in 2s.
      // - Lead user to the "contenteditable" area with Velocity scroll.
    
      copyCode.on('success', function(event) {
        event.clearSelection();
        event.trigger.textContent = 'Copied';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 2000);
    
      });
    
      // On error (Safari):
      // - Change the  "Press Ctrl+C to copy"
      // - Swap it to "Copy" in 2s.
    
      copyCode.on('error', function(event) {
        event.trigger.textContent = 'Press "Ctrl + C" to copy';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 5000);
      });
    
    })();
</script>
    
  </body>
</html>

<script>
  var coll = document.getElementsByClassName("collapsible");
  var i;

  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }
</script>

<script>
  var coll = document.getElementsByClassName("solutioncollapsible");
  const queryString = window.location.search;
  const urlParams = new URLSearchParams(queryString);
  const myVar = urlParams.get('solution')
  if ( myVar == 'true') {
    for (i = 0; i < coll.length; i++) {
      coll[i].style.display = "block";
    }
  }
</script>