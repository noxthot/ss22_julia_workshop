<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/ss22_julia_workshop/libs/katex/katex.min.css"> <link rel=stylesheet  href="/ss22_julia_workshop/libs/highlight/github.min.css"> <script src="/ss22_julia_workshop/libs/clipboard.min.js"></script> <link rel=stylesheet  href="/ss22_julia_workshop/css/jtd.css"> <link rel=stylesheet  href="/ss22_julia_workshop/css/extras.css"> <link rel=icon  href="/ss22_julia_workshop/assets/favicon.ico"> <style> /* #148 wrap long header */ .franklin-content a.header-anchor, .franklin-toc li a { word-wrap: break-word; white-space: normal; } </style> <title>Functions</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/ss22_julia_workshop/" class=title > Julia </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/ss22_julia_workshop/" class="menu-list-link ">Start</a> <li class="menu-list-item active"><a href="/ss22_julia_workshop/pages/introduction/" class="menu-list-link active">Introduction</a> <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/basis_datatypes_and_operations" class=menu-list-link >Basic Datatypes and Operations</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/matrix_vectors" class=menu-list-link >Matrix and Vector Operations</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/conditional_evaluations" class=menu-list-link >Conditional evaluations</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/loops" class=menu-list-link >Loops</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/functions" class=menu-list-link >Functions</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/worksheet_1" class=menu-list-link >Worksheet 1</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/introduction/worksheet_2" class=menu-list-link >Worksheet 2</a> </ul> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/" class="menu-list-link ">Data Science</a> <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/dataframes" class=menu-list-link >Dataframes</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/datascience/exploratory_da" class=menu-list-link >Exploratory Data Analysis</a> </ul> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/" class="menu-list-link ">Parallel computing</a> <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/performance" class=menu-list-link >Measuring performance</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/simd" class=menu-list-link >Single Instruction Multiple Data</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/pi" class=menu-list-link >&pi; example</a> <li class="menu-list-item "><a href="/ss22_julia_workshop/pages/hpc/multithreading" class=menu-list-link >Multithreading</a> </ul> </ul> </div> <div class=footer > This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target=_blank >Jekyll theme</a>. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > SS22 Julia Workshop Obergurgl </div> <div class=franklin-content ><h1 id=functions ><a href="#functions" class=header-anchor >Functions</a></h1> <p>To improve the structure and ensure reusability of pieces of you program you can use the <code>function</code> command. You have already used functions when for example calling <code>typeof&#40;input&#41;</code>. Other examples of functions that can be found on any common calculator are <code>sin&#40;x&#41;</code> or <code>exp&#40;x&#41;</code>. The syntax to define your own functions is the following:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo(input)
    <span class=hljs-comment ># function body that is executed when foo is called</span>
    <span class=hljs-keyword >return</span> output
<span class=hljs-keyword >end</span></code></pre> <p>So if you want to define a function which prints out and returns <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy=false >(</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">sin(cos(x))</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class=mopen >(</span><span class="mord mathnormal">cos</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >))</span></span></span></span> we can write</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos(x)
    result = sin(cos(x))
    println(<span class=hljs-string >&quot;sin(cos(&quot;</span>,x,<span class=hljs-string >&quot;)) = &quot;</span>,result)
    <span class=hljs-keyword >return</span> result
<span class=hljs-keyword >end</span></code></pre> <p>If we wish to specify multiple inputs and outputs we can do so as well:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos(x,y)
    result1 = sin(cos(x))
    result2 = sin(cos(y))
    println(<span class=hljs-string >&quot;sin(cos(&quot;</span>,x,<span class=hljs-string >&quot;)) = &quot;</span>,result1)
    println(<span class=hljs-string >&quot;sin(cos(&quot;</span>,y,<span class=hljs-string >&quot;)) = &quot;</span>,result2)
    <span class=hljs-keyword >return</span> result1, result2
<span class=hljs-keyword >end</span></code></pre> <p>You can call a function with multiple outputs via <code>out &#61; foo&#40;input&#41;</code> and access the output at index <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> through <code>out&#91;i&#93;</code>. You can also write &#40;assuming two outputs&#41; <code>out1,out2 &#61; foo&#40;input&#41;</code>.</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x = <span class=hljs-number >1</span>; y = <span class=hljs-number >1.5</span>;
</span><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > res1,res2 = sincos(x,y)
</span>sin(cos(1)) = 0.5143952585235492
sin(cos(1.5)) = 0.07067822452613834
(0.5143952585235492, 0.07067822452613834)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > res1
</span>0.5143952585235492

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > res = sincos(x,y);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > res[<span class=hljs-number >1</span>]
</span>0.5143952585235492</code></pre> <p>Julia functions do not copy the input but directly operate on the input data. This means that changing values of the input in the function body will also change this data for the function caller. Whenever you define a function which will modify the input, you should indicate this with a <code>&#33;</code> behind the function name:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos!(x)
    x .= sin.(cos.(x))
    <span class=hljs-keyword >return</span> x
<span class=hljs-keyword >end</span></code></pre> <p>Calling this function leads to</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x = ones(<span class=hljs-number >2</span>);
</span><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > println(<span class=hljs-string >&quot;Function value is &quot;</span>,sincos!(x))
</span>Function value is [0.5143952585235492, 0.5143952585235492]

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x
</span>2-element Vector{Float64}:
 0.5143952585235492
 0.5143952585235492</code></pre> <button type=button  class=collapsible  style="background-color:#b5ddff"> Exercise </button><div class=collapsiblecontent > Consider two implementations</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos1!(x)
    x .= sin.(cos.(x))
    <span class=hljs-keyword >return</span> x
<span class=hljs-keyword >end</span></code></pre> <p>and</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos2!(x)
    x = sin.(cos.(x))
    <span class=hljs-keyword >return</span> x
<span class=hljs-keyword >end</span></code></pre> <ol> <li><p>Evaluate both functions with the input <code>x &#61; ones&#40;2&#41;</code>. How does <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> change after calling the function? Explain this behaviour. Correct the function names accordingly.</p> <li><p>Build in the function <code>pointer_from_objref&#40;x&#41;</code> to see how the memory changes.</p> <li><p>Write a method which evaluates <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>cos</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\sin(\cos(x))</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class=mop >cos</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >))</span></span></span></span> and stores the result on <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> such that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is modified for the caller.</p> </ol> <p><p><div class=solution > Solution </div><div class=solutioncollapsible > 1. The function <code>sincos1&#33;&#40;x&#41;</code> will modify the input:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x = ones(<span class=hljs-number >2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > sincos1!(x);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x
</span>2-element Vector{Float64}:
 0.5143952585235492
 0.5143952585235492</code></pre> <p>The function <code>sincos2&#33;&#40;x&#41;</code> will not modify the input:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x = ones(<span class=hljs-number >2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > sincos2!(x);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x
</span>2-element Vector{Float64}:
 1.0
 1.0</code></pre> <p>The reason for this behaviour is that <code>sincos1</code> changes the input as Julia functions work with call-by-reference. I.e., they do not generate a local copy of the input and instead directly work on the same memory that has been used by the caller. This memory is not reallocated due to the use of <code>.&#61;</code>. On the other hand, <code>sincos2</code> allocates new memory, since <code>x &#61; sin.&#40;cos.&#40;x&#41;&#41;</code> will create new memory for <code>x</code> on which the values of <code>sin.&#40;cos.&#40;x&#41;&#41;</code> are stored. Hence the memory of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> known to the caller is not modified and the original values are preserved. Not that the name <code>sincos2&#33;&#40;x&#41;</code> is hence misleading and the function should be renamed to <code>sincos2&#40;x&#41;</code>.</p> <ol start=2 > <li><p>We have</p> </ol> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos1!(x)
    println(<span class=hljs-string >&quot;Address input: &quot;</span>,pointer_from_objref(x))
    x .= sin.(cos.(x))
    println(<span class=hljs-string >&quot;Address output: &quot;</span>,pointer_from_objref(x))
    <span class=hljs-keyword >return</span> x
<span class=hljs-keyword >end</span></code></pre> <p>and</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos2(x)
    println(<span class=hljs-string >&quot;Address input: &quot;</span>,pointer_from_objref(x))
    x = sin.(cos.(x))
    println(<span class=hljs-string >&quot;Address output: &quot;</span>,pointer_from_objref(x))
    <span class=hljs-keyword >return</span> x
<span class=hljs-keyword >end</span></code></pre> <p>Then,</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x = ones(<span class=hljs-number >2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > y = sincos1!(x);
</span>Address input: Ptr{Nothing} @0x00007f3325795b90
Address output: Ptr{Nothing} @0x00007f3325795b90

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x = ones(<span class=hljs-number >2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > println(<span class=hljs-string >&quot;Address caller: &quot;</span>,pointer_from_objref(x));
</span>Address caller: Ptr{Nothing} @0x00007f332671cab0

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > y = sincos1!(x);
</span>Address input: Ptr{Nothing} @0x00007f332671cab0
Address output: Ptr{Nothing} @0x00007f332671cab0

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > y = sincos2(x);
</span>Address input: Ptr{Nothing} @0x00007f332671cab0
Address output: Ptr{Nothing} @0x00007f33266e2310</code></pre> <ol start=3 > <li><p>This is not possible, since assigning a new value to a scalar <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> will always alter the memory location. </div></p> </ol> </div> <p>You might have observed that since we did not specify any datatypes, we were able to call functions using vectors and scalars. However, if we call <code>sincos1&#33;&#40;1.0&#41;</code> you see that this might not always be the best idea. Some functions should only be called with a certain datatype. We can specify the datatype of input and output in the following way:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos1!(x::<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>,<span class=hljs-number >2</span>})::<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>,<span class=hljs-number >2</span>}
    x .= sin.(cos.(x))
    <span class=hljs-keyword >return</span> x
<span class=hljs-keyword >end</span></code></pre> <p>As always you can use the dot operation to evaluate an array of inputs element-wise. Define the scalar function</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> sincos(x::<span class=hljs-built_in >Float64</span>)::<span class=hljs-built_in >Float64</span>
    <span class=hljs-keyword >return</span> sin(cos(x))
    
<span class=hljs-keyword >end</span></code></pre> <p>and run</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > x = ones(<span class=hljs-number >2</span>,<span class=hljs-number >3</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > sincos.(x)
</span>2×3 Matrix{Float64}:
 0.514395  0.514395  0.514395
 0.514395  0.514395  0.514395</code></pre> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Gregor Ehrensperger, Peter Kandolf, Jonas Kusch. Last modified: July 02, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> <!-- end of class page-wrap--> <script> (function(){ // Get the elements. // - the 'pre' element. // - the 'div' with the 'paste-content' id. var pre = document.getElementsByTagName('pre'); // Add a copy button in the 'pre' element. // which only has the className of 'language-'. for (var i = 0; i < pre.length; i++) { var isLanguage = pre[i].children[0].className.indexOf('language-'); if ( isLanguage === 0 ) { var button = document.createElement('button'); button.className = 'copy-button'; button.textContent = 'Copy'; pre[i].appendChild(button); } }; // Run Clipboard var copyCode = new Clipboard('.copy-button', { target: function(trigger) { return trigger.previousElementSibling; } }); // On success: // - Change the "Copy" text to "Copied". // - Swap it to "Copy" in 2s. // - Lead user to the "contenteditable" area with Velocity scroll. copyCode.on('success', function(event) { event.clearSelection(); event.trigger.textContent = 'Copied'; window.setTimeout(function() { event.trigger.textContent = 'Copy'; }, 2000); }); // On error (Safari): // - Change the "Press Ctrl+C to copy" // - Swap it to "Copy" in 2s. copyCode.on('error', function(event) { event.trigger.textContent = 'Press "Ctrl + C" to copy'; window.setTimeout(function() { event.trigger.textContent = 'Copy'; }, 5000); }); })(); </script> <script> var coll = document.getElementsByClassName("collapsible"); var i; for (i = 0; i < coll.length; i++) { coll[i].addEventListener("click", function() { this.classList.toggle("active"); var content = this.nextElementSibling; if (content.style.display === "block") { content.style.display = "none"; } else { content.style.display = "block"; } }); } </script> <script> var coll = document.getElementsByClassName("solution"); const queryString = window.location.search; const urlParams = new URLSearchParams(queryString); const myVar = urlParams.get('solution') console.log(myVar); if ( myVar == 'true') { for (i = 0; i < coll.length; i++) { coll[i].style.display = "block"; } } </script>